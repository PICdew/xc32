# It does some substitutions.
cat >e${EMULATION_NAME}.c <<EOF
/* This file is is generated by a shell script.  DO NOT EDIT! */

/* elf32pic32mx.em: emulate the original gld for the given ${EMULATION_NAME}
   Copyright 1991, 1992, 1994, 1996, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
   Written by Steve Chamberlain steve@cygnus.com
   Based on generic.em   
   Modified for Microchip PIC32 MCUs by Jason Kajita jason.kajita@microchip.com

This file is part of GLD, the Gnu Linker.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define TARGET_IS_${EMULATION_NAME}

#include "bfd.h"
#include "sysdep.h"
#include "bfdlink.h"
#include "getopt.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"

#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"

#include "libbfd.h"

#include <elf/pic32.h>

#include "../bfd/pic32-options.h"

#include "ctype.h"

struct traverse_hash_info
{
  bfd *abfd;
  asection *sec;
};

/* Memory Reporting Info */
struct magic_section_description_tag {
 char *name;
 char *description;
};

struct magic_sections_tag
{
  const struct magic_section_description_tag *sections;
  unsigned int count;
  unsigned int index;
  unsigned int start;
};

static void bfd_pic32_report_memory_usage
  PARAMS ((FILE *));

static void report_percent_used
  PARAMS ((bfd_vma, bfd_vma, FILE *));

static void pic32_build_section_list
  PARAMS ((bfd *, asection *, PTR));

static void pic32_init_section_list
  PARAMS ((struct pic32_section **));

static lang_memory_region_type *region_lookup
  PARAMS ((char *));

static bfd_size_type bfd_pic32_report_sections
  PARAMS ((asection *, const lang_memory_region_type *, 
           struct magic_sections_tag *, FILE *));

struct bfd_link_hash_entry *bfd_pic32_is_defined_global_symbol
  PARAMS ((const char *const));

static bfd_boolean bfd_pic32_undefine_one_symbol_bfd
  PARAMS ((struct bfd_link_hash_entry *, PTR));

static void bfd_pic32_undefine_symbols_bfd
  PARAMS ((bfd *));

static void bfd_pic32_remove_archive_module
  PARAMS ((const char *const));

static char * bfd_pic32_lookup_magic_section_description
  PARAMS ((const char *, struct magic_sections_tag *, char **));

/* Declare functions used by various EXTRA_EM_FILEs.  */
static void gld${EMULATION_NAME}_before_parse (void);
static void gld${EMULATION_NAME}_before_allocation (void);
static void gld${EMULATION_NAME}_after_open PARAMS ((void));
static void gld${EMULATION_NAME}_finish (void);

/* Memory Reporting Info */
static const struct magic_section_description_tag magic_pmdescriptions[] =
   {{"", ""},
   {".text", "Application's executable code"},
   {".rodata", "Read-only constant data"},
   {".sdata2", "Small initialized, constant global and static data template"},
   {".sbss2", "Small uninitialized, constant global and static data"},
   {".eh_frame_hdr", "Stack unwind header"},
   {".eh_frame", "Stack unwind info"},
   {".data", "Data-initialization template"},
   {".got", "Global offset table"},
   {".sdata", "Small data-initialization template"},
   {".lit8", "8-byte constants"},
   {".lit4", "4-byte constants"},
   {".ramfunc", "RAM-function template"},
   {".startup", "C startup code"},
   {".app_excpt", "General-Exception handler"},
   {".reset", "Reset handler"},
   {".bev_excpt", "BEV-Exception handler"},
   {".vector_0", "Interrupt Vector 0"},
   {".vector_1", "Interrupt Vector 1"},
   {".vector_2", "Interrupt Vector 2"},
   {".vector_3", "Interrupt Vector 3"},
   {".vector_4", "Interrupt Vector 4"},
   {".vector_5", "Interrupt Vector 5"},
   {".vector_6", "Interrupt Vector 6"},
   {".vector_7", "Interrupt Vector 7"},
   {".vector_8", "Interrupt Vector 8"},
   {".vector_9", "Interrupt Vector 9"},
   {".vector_10", "Interrupt Vector 10"},
   {".vector_11", "Interrupt Vector 11"},
   {".vector_12", "Interrupt Vector 12"},
   {".vector_13", "Interrupt Vector 13"},
   {".vector_14", "Interrupt Vector 14"},
   {".vector_15", "Interrupt Vector 15"},
   {".vector_16", "Interrupt Vector 16"},
   {".vector_17", "Interrupt Vector 17"},
   {".vector_18", "Interrupt Vector 18"},
   {".vector_19", "Interrupt Vector 19"},
   {".vector_20", "Interrupt Vector 20"},
   {".vector_21", "Interrupt Vector 21"},
   {".vector_22", "Interrupt Vector 22"},
   {".vector_23", "Interrupt Vector 23"},
   {".vector_24", "Interrupt Vector 24"},
   {".vector_25", "Interrupt Vector 25"},
   {".vector_26", "Interrupt Vector 26"},
   {".vector_27", "Interrupt Vector 27"},
   {".vector_28", "Interrupt Vector 28"},
   {".vector_29", "Interrupt Vector 29"},
   {".vector_30", "Interrupt Vector 30"},
   {".vector_31", "Interrupt Vector 31"},
   {".vector_32", "Interrupt Vector 32"},
   {".vector_33", "Interrupt Vector 33"},
   {".vector_34", "Interrupt Vector 34"},
   {".vector_35", "Interrupt Vector 35"},
   {".vector_36", "Interrupt Vector 36"},
   {".vector_37", "Interrupt Vector 37"},
   {".vector_38", "Interrupt Vector 38"},
   {".vector_39", "Interrupt Vector 39"},
   {".vector_40", "Interrupt Vector 40"},
   {".vector_41", "Interrupt Vector 41"},
   {".vector_42", "Interrupt Vector 42"},
   {".vector_43", "Interrupt Vector 43"},
   {".vector_44", "Interrupt Vector 44"},
   {".vector_45", "Interrupt Vector 45"},
   {".vector_46", "Interrupt Vector 46"},
   {".vector_47", "Interrupt Vector 47"},
   {".vector_48", "Interrupt Vector 48"},
   {".vector_49", "Interrupt Vector 49"},
   {".vector_50", "Interrupt Vector 50"},
   {".vector_51", "Interrupt Vector 51"},
   {".vector_52", "Interrupt Vector 52"},
   {".vector_53", "Interrupt Vector 53"},
   {".vector_54", "Interrupt Vector 54"},
   {".vector_55", "Interrupt Vector 55"},
   {".vector_56", "Interrupt Vector 56"},
   {".vector_57", "Interrupt Vector 57"},
   {".vector_58", "Interrupt Vector 58"},
   {".vector_59", "Interrupt Vector 59"},
   {".vector_60", "Interrupt Vector 60"},
   {".vector_61", "Interrupt Vector 61"},
   {".vector_62", "Interrupt Vector 62"},
   {".vector_63", "Interrupt Vector 63"}
   };

static const struct magic_section_description_tag magic_dmdescriptions[] =
   {{"", ""},
   {".data", "Initialized data"},
   {".got", "Global offset table"},
   {".sdata", "Small initialized data"},
   {".lit8", "8-byte constants"},
   {".lit4", "4-byte constants"},
   {".sbss", "Small uninitialized data"},
   {".bss", "Uninitialized data"},
   {".heap", "Dynamic Memory heap"},
   {".stack", "Minimum space reserved for stack"},
   {".ramfunc", "RAM functions"}};

struct magic_sections_tag magic_dm = 
{
  magic_dmdescriptions,
  0, 0, 0
};
struct magic_sections_tag magic_pm = 
{
  magic_pmdescriptions,
  0, 0, 0
};

static bfd_size_type actual_prog_memory_used = 0;
static bfd_size_type data_memory_used = 0;
static bfd_size_type region_data_memory_used = 0;

/* Section Lists */
static struct pic32_section *pic32_section_list;

/*
** smart_io Data Structure
**
** The following data structure is used to identify
** I/O function pairs that have redundant functionality.
** The "full_set" function is a standard I/O function
** such as printf(). The "reduced_set" function has the
** same type and parameter list but supports a reduced
** feature set, such as the integer-only _iprintf().
**
** If both members of a function pair are defined,
** the reduced_set function is considered redundant.
** The --smart-io option causes the linker to merge
** the two functions in order to conserve memory.
**
** Function merging is performed by the _after_open()
** emulation entry point, after all the input BFDs
** have been opened, but before memory is allocated.
**
** Function merging consists of several steps:
**
** 1. Lookup both function names in the Global Linker
**    Hash Table and load pointers to the corresponding
**    hash table entries.
**
** 2. Copy the (value) and (section) fields from the
**    full_set hash table entry to the reduced_set hash
**    table entry. This causes the reduced_set function
**    name to be a synonym for the full_set function name.
**
**    This operation is valid because:
**
**    (section) is a pointer into a BFD data structure.
**    When a BFD is opened, it remains locked in memory
**    until it is closed at the completion of the link.
**    Pointers into a BFD data structure are guaranteed
**    not to move.
**
**    (value) is an offset into an input section. Offsets
**    within an input section are determined by the
**    assembler and do not change during the link.
**
** 3. Loop through each input statement in the linker script
**    and find the BFD associated with the reduced_set
**    function, based on its module_name.
**
** 4. Traverse the Global Linker Hash Table and change the
**    type of any symbols that are defined and owned by
**    the reduced_set BFD to "undefined".
**
** 5. For each section attached to the reduced_set BFD,
**    set the SEC_NEVER_LOAD section flag and set the
**    section size to zero. This causes the reduced_set
**    function to be omitted from the final link.
*/

struct function_pair_type
{
  char *full_set;
  char *reduced_set;
  char *module_name;
};

const struct function_pair_type function_pairs[] =
  {
    /* iprintf() */
    { "printf",    "_iprintf",   "iprintf.o"    },

    /* ifprintf() */
    { "fprintf",   "_ifprintf",  "ifprintf.o"   },

    /* isprintf() */
    { "sprintf",   "_isprintf",  "isprintf.o"   },

    /* ivprintf() */
    { "vprintf",   "_ivprintf",  "ivprintf.o"   },

    /* ivfprintf() */
    { "vfprintf",  "_ivfprintf",  "_idoprnt.o" },

    /* ivsprintf() */
    { "vsprintf",  "_ivsprintf",  "isprintf.o" },

    /* isnprintf() */
    { "snprintf",  "_isnprintf",  "isnprintf.o" },

    /* ivsnprintf() */
    { "vsnprintf", "_ivsnprintf", "ivsnprintf.o" },

    /* __vsnprintf() */
    { "__vsnprintf",  "__ivsnprintf",  "__ivsnprintf.o" },

    /* __vasprintf() */
    { "__vasprintf",  "__ivasprintf",  "__ivasprintf.o" },

    /* vasprintf() */
    { "vasprintf",  "_ivasprintf",  "ivasprintf.o" },

    /* asprintf() */
    { "asprintf",  "_iasprintf",  "iasprintf.o" },


    /* iscanf() */
    { "scanf",     "_iscanf",     "iscanf.o"    },

    /* ifscanf() */
    { "fscanf",    "_ifscanf",    "iscanf.o"   },

    /* isscanf() */
    { "sscanf",    "_isscanf",    "isscanf.o"   },

    /* vfscanf() */
    { "vfscanf",    "_ivfscanf",    "_idoscan.o"   },

    /* vsscanf() */
    { "vsscanf",    "_ivsscanf",    "isscanf.o"   },

    /* vscanf() */
    { "vscanf",    "_ivscanf",    "iscanf.o"   },

    /* null terminator */
    { 0, 0, 0 },
  };

EOF

# Import any needed special functions and/or overrides.
#
if test -n "$EXTRA_EM_FILE" ; then
. ${srcdir}/emultempl/${EXTRA_EM_FILE}.em
fi

cat >>e${EMULATION_NAME}.c <<EOF


/*
** Utility routine: bfd_pic32_report_memory_usage
**
** - print a section chart to file *fp
**/
static void
bfd_pic32_report_memory_usage (fp)
     FILE *fp;
{
  bfd_size_type region_prog_memory_used;
  bfd_size_type total_prog_memory, total_data_memory;
  lang_memory_region_type *region;
  unsigned int region_index, region_count;
  struct pic32_section *s;
  struct region_report_tag {
    char *name;
    char *title;
    char *total;
  };
  struct region_report_tag pmregions_to_report[] = 
    {{"kseg0_program_mem", 
      "kseg0 Program-Memory Usage", 
      "      Total kseg0_program_mem used"},
     {"kseg0_boot_mem",
      "kseg0 Boot-Memory Usage",
      "         Total kseg0_boot_mem used"},
     {"exception_mem",
      "Exception-Memory Usage ",
      "          Total exception_mem used"},
     {"kseg1_boot_mem",
      "kseg1 Boot-Memory Usage",
      "         Total kseg1_boot_mem used"}};

  struct region_report_tag dmregions_to_report[] = 
    {{"kseg1_data_mem", 
      "kseg1 Data-Memory Usage", 
      "         Total kseg1_data_mem used"}};

  /* clear the counters */
  actual_prog_memory_used = 0;
  data_memory_used = 0;
  region_prog_memory_used = 0;
  region_data_memory_used = 0;
  total_data_memory = total_prog_memory = 0;

  fprintf( fp, "\nMicrochip PIC32 Memory-Usage Report");
  
  /* build an ordered list of output sections */
  pic32_init_section_list(&pic32_section_list);
  bfd_map_over_sections(output_bfd, &pic32_build_section_list, NULL);

  region_count = sizeof(pmregions_to_report)/sizeof(pmregions_to_report[0]);
  magic_pm.count = sizeof(magic_pmdescriptions)/sizeof(magic_pmdescriptions[0]);
  magic_pm.start = magic_pm.index = 0;
  for (region_index = 0; region_index < region_count; region_index++)
  {
     region = region_lookup(pmregions_to_report[region_index].name);
     
     /* print code header */
     fprintf( fp, "\n\n%s\n", pmregions_to_report[region_index].title);
     fprintf( fp, "section                    address  length [bytes]      (dec)  Description\n");
     fprintf( fp, "-------                 ----------  -------------------------  -----------\n");
     /* report code sections */
     for (s = pic32_section_list; s != NULL; s = s->next)
       if (s->sec)
       {
         region_prog_memory_used += bfd_pic32_report_sections (s->sec, region, &magic_pm,fp);
       }
     fprintf( fp, "%s  :  %#10lx  %10ld  ",
            pmregions_to_report[region_index].total,
            (unsigned long)region_prog_memory_used, (unsigned long)region_prog_memory_used);
     report_percent_used(region_prog_memory_used,region->length, fp);
     total_prog_memory += region->length;
     actual_prog_memory_used += region_prog_memory_used;
     region_prog_memory_used = 0;
   }

  /* -------------------- */
  /*  print code summary  */
  /* -------------------- */

  fprintf (fp, "\n        --------------------------------------------------------------------------\n");
  fprintf (fp,     "         Total Program Memory used  :  %#10lx  %10ld  ",
         actual_prog_memory_used, actual_prog_memory_used);
  report_percent_used (actual_prog_memory_used, total_prog_memory, fp);
  fprintf (fp, "\n        --------------------------------------------------------------------------\n");

  /* DATA MEMORY */

  region_count = sizeof(dmregions_to_report)/sizeof(dmregions_to_report[0]);
  magic_dm.count = sizeof(magic_dmdescriptions)/sizeof(magic_dmdescriptions[0]);
  magic_dm.start = magic_dm.index = 0;
  for (region_index = 0; region_index < region_count; region_index++)
  {
     region = region_lookup(dmregions_to_report[region_index].name);
     /* print code header */
     fprintf( fp, "\n\n%s\n", dmregions_to_report[region_index].title);
     fprintf( fp, "section                    address  length [bytes]      (dec)  Description\n");
     fprintf( fp, "-------                 ----------  -------------------------  -----------\n");
     /* report code sections */
     for (s = pic32_section_list; s != NULL; s = s->next)
       if (s->sec)
       {
         region_data_memory_used += bfd_pic32_report_sections (s->sec, region, &magic_dm, fp);
       }

     fprintf( fp, "%s  :  %#10lx  %10ld  ",
            dmregions_to_report[region_index].total,
            (unsigned long)region_data_memory_used, (unsigned long)region_data_memory_used);
     report_percent_used(region_data_memory_used,region->length, fp);
     total_data_memory += region->length;
     data_memory_used += region_data_memory_used;
     region_data_memory_used = 0;
   }

  /* -------------------- */
  /*  print data summary  */
  /* -------------------- */

  fprintf( fp, "\n        --------------------------------------------------------------------------\n");
  fprintf( fp,     "            Total Data Memory used  :  %#10lx  %10ld  ",
         data_memory_used, data_memory_used);
  report_percent_used (data_memory_used, total_data_memory, fp);
  fprintf( fp, "\n        --------------------------------------------------------------------------\n");

} /* static void bfd_pic32_report_memory_usage (...)*/

static void
report_percent_used (used, max, fp)
     bfd_vma used, max;
     FILE *fp;
{
  double percent;
  
  if (max > 0) {
     percent = 100 * ((float) used/max);

     if (percent)
       fprintf( fp, "%.1f%% of %#lx", percent, max);
     else
       fprintf( fp, "<1%% of %#lx", max);
   }
}

/*
** Return a pointer to bfd_link_hash_entry
** if a global symbol is defined;
** else return zero.
*/
struct bfd_link_hash_entry *
bfd_pic32_is_defined_global_symbol (name)
     const char *const name;
{
    struct bfd_link_hash_entry *h;
    h = bfd_link_hash_lookup (link_info.hash, name, FALSE, FALSE, TRUE);
    if ((h != (struct bfd_link_hash_entry *) NULL) &&
        (h->type == bfd_link_hash_defined)) {
      return h;
    }
    else
      return (struct bfd_link_hash_entry *) NULL;
}

/*
** Undefine one symbol by BFD
**
** This routine is called by bfd_link_hash_traverse()
*/
static bfd_boolean
bfd_pic32_undefine_one_symbol_bfd (h, p)
     struct bfd_link_hash_entry *h;
     PTR p;
{
  struct bfd_link_hash_entry *H = (struct bfd_link_hash_entry *) h;
  struct traverse_hash_info *info = ( struct traverse_hash_info *) p;

  /* if this symbol is defined, and owned by the BFD in question */
  if ((( H->type == bfd_link_hash_defined) ||
       ( H->type == bfd_link_hash_defweak)) &&
      ( H->u.def.section->owner == info->abfd))

    /* mark it undefined */
    H->type = bfd_link_hash_undefined;

  /* traverse the entire hash table */
  return TRUE;
} /* static bfd_boolean bfd_pic32_undefine_one_symbol_bfd (...)*/


/*
** Undefine all symbols owned by a bfd
*/
static void
bfd_pic32_undefine_symbols_bfd (target)
     bfd *target;
{
    struct traverse_hash_info info;
    info.abfd = target;

    /* traverse the global linker hash table */
    bfd_link_hash_traverse (link_info.hash,
       bfd_pic32_undefine_one_symbol_bfd, &info);

} /* static void bfd_pic32_undefine_symbols_bfd (...) */

/*
** Remove an archive module
*/
static void
bfd_pic32_remove_archive_module (name)
     const char *const name;
{
  LANG_FOR_EACH_INPUT_STATEMENT (is)
  {
      if (strcmp (is->the_bfd->filename, name) == 0)
      {
          if (pic32_debug)
          {
              printf("\nRemoving %s\n", name);
              printf("  %s had %d symbols\n", name , is->the_bfd->symcount);
          }

          /*
          ** remove the symbols
          */
          bfd_pic32_undefine_symbols_bfd (is->the_bfd);
          is->the_bfd->symcount = 0;

          /*
          ** remove the sections in this bfd
          */
          bfd_section_list_clear(is->the_bfd);
          break;
      }
  }
} /* static void bfd_pic32_remove_archive_module */

/*****************************************************************************
**
** Section List Routines
**
** Maintain a list of sections in order
** of ascending load address.
**
** Used for creating memory usage reports.
**
*/

/*
** Create a new list
**
** - first item is null
*/
static void
pic32_init_section_list(lst)
     struct pic32_section **lst;
{
  *lst = ((struct pic32_section *)
         xmalloc(sizeof(struct pic32_section)));
  if (NULL == lst) { 
    fprintf( stderr, "Fatal Error: Not enough memory to initialize section list\n");
    abort();
  }
  (*lst)->next = 0;
  (*lst)->sec = 0;
  (*lst)->attributes = 0;
  (*lst)->file = 0;
}


/*
** Add a section to the list
**
** - in order of increasing load address
** - this function is called via bfd_map_over_sections()
*/
static void
pic32_build_section_list (abfd, sect, fp)
     bfd *abfd ATTRIBUTE_UNUSED ;
     asection *sect;
     PTR fp ATTRIBUTE_UNUSED ;
{
  struct pic32_section *new, *s, *prev;
  int done = 0;

  /* create a new element */
  new = ((struct pic32_section *) 
         xmalloc(sizeof(struct pic32_section)));
  if (NULL == new) { 
    fprintf( stderr, "Fatal Error: Could not build section list\n");
    abort();
  }
  new->sec  = sect;
  new->file = 0;

  /* insert it at the right spot */
  prev = pic32_section_list;
  for (s = prev; s != NULL; s = s->next)
    {
      if (s->sec && (new->sec->lma < s->sec->lma))
        {
          prev->next = new;
          new->next = s;
          done++;
          break;
        }
      prev = s;
    }

  if (!done)
    {
      prev->next = new;
      new->next = NULL;
    }
} /* static void pic32_build_section_list (...) */

/*
** region_lookup()
**
** Call this instead of lang_memory_region_lookup()
** if you want reasonable defaults set for the
** following regions:
**
** data
** program
**
** Note: Ideally, every linker script will include
** these definitions. But we don't want to fail
** if the user is running with a minimal script.
*/
#define NAME_IS(s) \
  ((strlen(name) == strlen(#s)) && \
           strcmp(name, (#s)) == 0)

static lang_memory_region_type *
region_lookup( name )
     char * name;
{
  lang_memory_region_type *region;
  bfd_vma upper_limit = 0;
  int use_default = 0;

  region = lang_memory_region_lookup (name, FALSE);
  if (region->length == ~(bfd_size_type) 0) {
    if (NAME_IS(kseg0_program_mem)) {
      use_default = 1;
      region->origin = 0x9D000000;     /* works with 32MX320F512L */
      region->length = 0x80000;
      upper_limit    = (region->origin + region->length)-1;
    }
    else if (NAME_IS(kseg0_boot_mem)) {
      use_default = 1;
      region->origin = 0x9FC00490;     /* works with 32MX320F512L */
      region->length = 0x970;
      upper_limit    = (region->origin + region->length)-1;
    }
    else if (NAME_IS(exception_mem)) {
      use_default = 1;
      region->origin = 0x9FC01000;     /* works with 32MX320F512L */
      region->length = 0x1000;
      upper_limit    = (region->origin + region->length)-1;
    }
    else if (NAME_IS(kseg1_boot_mem)) {
      use_default = 1;
      region->origin = 0x9FC01000;     /* works with 32MX320F512L */
      region->length = 0x490;
      upper_limit    = (region->origin + region->length)-1;
    }
    else if (NAME_IS(kseg1_data_mem)) {
      use_default = 1;
      region->origin = 0xA0000000;     /* works with 32MX320F512L */
      region->length = 0x8000;
      upper_limit    = (region->origin + region->length)-1;
    }
    else
      einfo("Memory region %s does not exist\n", name);

    if (use_default) {
      einfo(_("%P: Warning: %s memory region not defined,"
              " using default range: 0x%v .. 0x%v\n"),
            name, region->origin, upper_limit);
      region->current = region->origin;
    }
  }
  return region;
}

/*
** Utility routine: bfd_pic32_report_sections()
**
** - show memory usage of SEC_ALLOC-flagged sections in memory
*/ 
static bfd_size_type
bfd_pic32_report_sections (sect, region, magic_sections, fp) 
     asection *sect;
     const lang_memory_region_type *region;
     struct magic_sections_tag *magic_sections;
     FILE *fp;
{
  char *description;
  bfd_size_type region_used = 0;
  unsigned long start = sect->vma;
  unsigned long load  = sect->lma;
  unsigned long actual = sect->size;

  /* 
  ** report SEC_ALLOC sections in memory
  */
  if ((sect->flags & SEC_ALLOC)
  &&  (sect->size > 0))
    {
      char *name, *c;

      /* make a local copy of the name */
      name = xmalloc(strlen(sect->name) + 1);
      if (NULL == name) { 
        fprintf( stderr, "Fatal Error: Could not copy section name\n");
        abort();
      }
      strcpy(name, sect->name);

      /* clean the name of %n */
      c = strchr(name, '%');
      if (c) *c = (char) '\0';

      if ((start >= region->origin)
        &&  ((start + actual) <= (region->origin + region->length)))
      {
         bfd_pic32_lookup_magic_section_description (name, magic_sections, &description);
         fprintf( fp, "%-24s%#10lx     %#10lx  %10ld  %s \n", name,
                 start, actual, actual, description);
         region_used = actual;
      }
      else if ((load >= region->origin) 
        &&  ((load + actual) <= (region->origin + region->length)))
      {
         bfd_pic32_lookup_magic_section_description (name, magic_sections, &description);
         fprintf( fp, "%-24s%#10lx     %#10lx  %10ld  %s \n", name,
                  load, actual, actual, description);
         region_used = actual;
      }
      free(name);
    }
  return region_used;
} /* static bfd_size_type bfd_pic32_report_sections (...) */

static const char empty_string[] = "";
static char * bfd_pic32_lookup_magic_section_description (name, magic_sections, description)
     const char *name;
     struct magic_sections_tag *magic_sections;
     char **description;
{     
      /* Assume that we don't have a description for the magic section name */
      *description = &empty_string[0];
      do
      {
        if (strcmp(name, magic_sections->sections[magic_sections->index].name))
        {
          /* Keep searching */
          magic_sections->index++;
          if (magic_sections->index == magic_sections->count)
            magic_sections->index = 0;
        }
        else
        {
          *description = magic_sections->sections[magic_sections->index].description;
          break;
        }
      } while(magic_sections->index != magic_sections->start);
      /* Start the next search where this one left off. */
      magic_sections->start = magic_sections->index;
      
      return *description;
} /* static void char * bfd_pic32_lookup_magic_section_description (...) */
EOF

if test x"$LDEMUL_BEFORE_PARSE" != xgld"$EMULATION_NAME"_before_parse; then
cat >>e${EMULATION_NAME}.c <<EOF

static void
gld${EMULATION_NAME}_before_parse (void)
{
#ifndef TARGET_			/* I.e., if not generic.  */
  ldfile_set_output_arch ("`echo ${ARCH}`", bfd_arch_unknown);
#endif /* not TARGET_ */
}

EOF
fi

if test x"$LDEMUL_AFTER_OPEN" != xgld"$EMULATION_NAME"_after_open; then
cat >>e${EMULATION_NAME}.c <<EOF
/*
** after_open() is called after all input BFDS
** have been created.
**
*/
static void
gld${EMULATION_NAME}_after_open()
{

  /*
  ** Merge full- and reduced-set I/O functions
  */
  if (pic32_smart_io)
    {
      int i = 0;

      if (pic32_debug)
        printf("\nMerging smart-io functions:\n");

      while ( function_pairs[i].full_set )

        {
          struct bfd_link_hash_entry *full, *reduced;
          char *func1, *func2;

          func1 = function_pairs[i].full_set;
          func2 = function_pairs[i].reduced_set;
          if (pic32_debug)
            printf("\nLooking for (%s, %s) ...", func1, func2);

          if ((full = bfd_pic32_is_defined_global_symbol (func1)) &&
              (reduced = bfd_pic32_is_defined_global_symbol (func2)))
            {
              if (pic32_debug)
                printf("Found\n\nRedirecting %s -> %s\n", func2, func1);

              /* redirect reduced_set function to full_set function */
              reduced->u.def.value = full->u.def.value;
              reduced->u.def.section = full->u.def.section;

              /* remove the reduced_set module */
              bfd_pic32_remove_archive_module (function_pairs[i].module_name);
            }
          else
            if (pic32_debug)
              printf("Not Found\n");
          i++;
        }
    } /* pic32_smart_io */


}

EOF
fi

cat >>e${EMULATION_NAME}.c <<EOF
/*
** finish()
**
** This function is called after symbol assignments
** are completed, but before relocations are resolved.
*/
static void  
gld${EMULATION_NAME}_finish()
{
  if (pic32_debug)
    printf ("gld_finish\n");
  if (config.map_file != NULL) {
    bfd_pic32_report_memory_usage (config.map_file);
  }
  if (pic32_report_mem)
    bfd_pic32_report_memory_usage (stdout);
} /* static void gld${EMULATION_NAME}_finish ()*/

EOF

if test x"$LDEMUL_GET_SCRIPT" != xgld"$EMULATION_NAME"_get_script; then
cat >>e${EMULATION_NAME}.c <<EOF

#include "../bfd/pic32-options.c"

static char *
gld${EMULATION_NAME}_get_script (int *isfile)
EOF

if test -n "$COMPILE_IN"
then
# Scripts compiled in.

# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 0;

  if (link_info.relocatable && config.build_constructors)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                 >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                 >> e${EMULATION_NAME}.c
echo '  ; else return'                                 >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                  >> e${EMULATION_NAME}.c
echo '; }'                                             >> e${EMULATION_NAME}.c

else
# Scripts read from the filesystem.

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 1;

  if (link_info.relocatable && config.build_constructors)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocatable)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
  else
    return "ldscripts/${EMULATION_NAME}.x";
}
EOF
fi
fi

cat >>e${EMULATION_NAME}.c <<EOF

struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
{
  ${LDEMUL_BEFORE_PARSE-gld${EMULATION_NAME}_before_parse},
  ${LDEMUL_SYSLIB-syslib_default},
  ${LDEMUL_HLL-hll_default},
  ${LDEMUL_AFTER_PARSE-after_parse_default},
  gld${EMULATION_NAME}_after_open,
  ${LDEMUL_AFTER_ALLOCATION-after_allocation_default},
  ${LDEMUL_SET_OUTPUT_ARCH-set_output_arch_default},
  ${LDEMUL_CHOOSE_TARGET-ldemul_default_target},
  ${LDEMUL_BEFORE_ALLOCATION-before_allocation_default},
  ${LDEMUL_GET_SCRIPT-gld${EMULATION_NAME}_get_script},
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  ${LDEMUL_FINISH-gld${EMULATION_NAME}_finish},
  ${LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS-NULL},
  ${LDEMUL_OPEN_DYNAMIC_ARCHIVE-NULL},
  ${LDEMUL_PLACE_ORPHAN-NULL},
  ${LDEMUL_SET_SYMBOLS-NULL},
  elf32pic32mx_parse_args,
  NULL,	/* add_options */
  NULL,	/* handle_option */
  ${LDEMUL_UNRECOGNIZED_FILE-NULL},
  ${LDEMUL_LIST_OPTIONS-elf32pic32mx_list_options},
  ${LDEMUL_RECOGNIZED_FILE-NULL},
  ${LDEMUL_FIND_POTENTIAL_LIBRARIES-NULL},
  ${LDEMUL_NEW_VERS_PATTERN-NULL}
};
EOF
